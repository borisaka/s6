#!/usr/bin/execlineb -S0

# drop the container-provided environment as soon quickly as possible; the only
# reliably available tmpfs is /dev, so we dump there and link it under /run
/usr/bin/foreground { /usr/bin/s6-dumpenv /dev/env }
/usr/bin/emptyenv /usr/bin/s6-envdir /etc/s6-init/env

# we have /run, /tmp linked to tmpfs paths because docker only mounts /dev, so
# we have to create the destination directories
background {
  if -n { test -e /tmp }
  backtick -in tmp_dest { readlink /tmp }
  import -u tmp_dest
  mkdir -m 1777 $tmp_dest
}
background {
  if -n { test -e /run }
  backtick -in run_dest { readlink /run }
  import -u run_dest
  cp -a /etc/s6-init/run $run_dest
}
wait { }

# /tmp available, /run tree ready

# if the user provided a command, exec into that with the container env
ifelse { test $# -gt 0 } { /etc/s6-init/user-cmd $@ }

foreground { mkfifo -m 0600 /run/s6/uncaught-logs/in }
foreground { mkdir -pm 2700 /var/log/uncaught }
foreground {
  s6-envuidgid -D 65534:65534 nobody
  s6-chown -U /var/log/uncaught
}

# standard trickery to open the pipe before a reader exists
redirfd -wnb 2 /run/s6/uncaught-logs/in fdmove -c 1 2

background {
  redirfd -w 2 /run/s6/uncaught-logs/in fdmove -c 1 2
  /etc/s6-init/stage2
}

emptyenv -p
s6-svscan -St0 /run/s6
