#!/usr/bin/ruby
Dir.chdir "/"

# drop the container-provided environment as soon quickly as possible; the only
# reliably available tmpfs is /dev, so we dump there and link it under /run
spawn "/usr/bin/s6-dumpenv", "/dev/env"
ENV.clear
ENV["PATH"] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin/"

if !File.exist?(tmp_dest = begin File.readlink "tmp" rescue "tmp" end)
  Dir.mkdir tmp_dest
  File.chmod 01777, tmp_dest
end

if !File.exist?(run_dest = begin File.readlink "run" rescue "run" end)
  Dir.mkdir run_dest
  File.chmod 0755, run_dest
end

IO.pipe do |r,w|
  spawn "tar", "-xC", "/run", 0=>r
  spawn "tar", "-cC", "/etc/s6-init/run", ".", 1=>w
end

Process.waitall # /tmp available, /run tree ready

# if the user provided a command, exec into that with the container env
ARGV.size > 0 and exec "/etc/s6-init/user-cmd", *ARGV

fifo = "/run/s6/uncaught-logs/in"

require '/etc/s6-init/libc' # need ffi mkfifo

if F_libc.mkfifo(fifo, 0600) < 0
  raise SystemCallError.new fifo, Fiddle.last_error
end

if !File.exist?(log_dest = "/var/log/uncaught")
  Dir.mkdir log_dest
  File.chmod 02700, log_dest

  require 'etc'
  nobody = Etc.getpwnam "nobody"
  File.chown nobody.uid, nobody.gid, log_dest
end

fork do
  open(fifo).close

  $stdout.reopen fifo, "w"
  $stderr.reopen $stdout

  exec "/etc/s6-init/stage2"
end

$stdout.reopen fifo, "w"
$stderr.reopen $stdout
exec "s6-svscan", "-St0", "/run/s6"
